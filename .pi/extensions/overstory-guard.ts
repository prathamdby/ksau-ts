// .pi/extensions/overstory-guard.ts
// Generated by overstory — do not edit manually.
// Agent: coordinator | Capability: coordinator
//
// Uses Pi's ExtensionAPI factory style: export default function(pi: ExtensionAPI) { ... }
// pi.on("tool_call", ...) returns { block: true, reason } to prevent tool execution.
// pi.exec("ov", [...]) calls the overstory CLI for activity tracking and lifecycle.
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

const AGENT_NAME = "coordinator";
const WORKTREE_PATH = "/home/prathamd/Documents/GitHub/ksau-ts";

// Native team/task tools blocked (all agents) — use ov sling for delegation.
// Safety net: Pi does not use Claude Code team tool names natively.
const TEAM_BLOCKED = new Set<string>([
  "Task",
  "TeamCreate",
  "TeamDelete",
  "SendMessage",
  "TaskCreate",
  "TaskUpdate",
  "TaskList",
  "TaskGet",
  "TaskOutput",
  "TaskStop",
]);

// Interactive tools blocked (all agents) — escalate via ov mail instead.
// Safety net: Pi does not use these Claude Code tool names natively.
const INTERACTIVE_BLOCKED = new Set<string>([
  "AskUserQuestion",
  "EnterPlanMode",
  "EnterWorktree",
]);

// Write tools blocked for non-implementation capabilities.
// Includes Pi lowercase names ("write", "edit") and Claude Code names for compat.
const WRITE_BLOCKED = new Set<string>([
  "write",
  "edit",
  "Write",
  "Edit",
  "NotebookEdit",
]);

// Write-scope tools where path boundary is enforced (all agents, defense-in-depth).
// Pi uses lowercase tool names; also include Claude Code names for forward compat.
const WRITE_SCOPE_TOOLS = new Set<string>([
  "write",
  "edit",
  "Write",
  "Edit",
  "NotebookEdit",
]);

// Safe Bash command prefixes — checked before the dangerous pattern blocklist.
const SAFE_PREFIXES = [
  "ov ",
  "overstory ",
  "bd ",
  "sd ",
  "git status",
  "git log",
  "git diff",
  "git show",
  "git blame",
  "git branch",
  "mulch ",
  "git add",
  "git commit",
  "bun test",
  "bun run lint",
  "bun run typecheck",
];

// Dangerous Bash patterns blocked for non-implementation agents.
const DANGEROUS_PATTERNS = [
  /sed\s+-i/,
  /sed\s+--in-place/,
  /echo\s+.*>/,
  /printf\s+.*>/,
  /cat\s+.*>/,
  /tee\s/,
  /\bvim\b/,
  /\bnano\b/,
  /\bvi\b/,
  /\bmv\s/,
  /\bcp\s/,
  /\brm\s/,
  /\bmkdir\s/,
  /\btouch\s/,
  /\bchmod\s/,
  /\bchown\s/,
  />>/,
  /\bgit\s+add\b/,
  /\bgit\s+commit\b/,
  /\bgit\s+merge\b/,
  /\bgit\s+push\b/,
  /\bgit\s+reset\b/,
  /\bgit\s+checkout\b/,
  /\bgit\s+rebase\b/,
  /\bgit\s+stash\b/,
  /\bnpm\s+install\b/,
  /\bbun\s+install\b/,
  /\bbun\s+add\b/,
  /\bbun\s+-e\b/,
  /\bbun\s+--eval\b/,
  /\bnode\s+-e\b/,
  /\bnode\s+--eval\b/,
  /\bdeno\s+eval\b/,
  /\bpython3?\s+-c\b/,
  /\bperl\s+-e\b/,
  /\bruby\s+-e\b/,
];

// File-modifying Bash patterns requiring path boundary validation (implementation agents).
const FILE_MODIFYING_PATTERNS = [
  /sed\s+-i/,
  /sed\s+--in-place/,
  /echo\s+.*>/,
  /printf\s+.*>/,
  /cat\s+.*>/,
  /tee\s/,
  /\bmv\s/,
  /\bcp\s/,
  /\brm\s/,
  /\bmkdir\s/,
  /\btouch\s/,
  /\bchmod\s/,
  /\bchown\s/,
  />>/,
  /\binstall\s/,
  /\brsync\s/,
];

export default function (pi: ExtensionAPI) {
  /**
   * Tool call guard + activity tracking.
   *
   * Fires before each tool executes. Returns { block: true, reason } to block.
   * Fire-and-forgets "ov log tool-start" to update lastActivity in the SessionStore,
   * preventing the Tier 0 watchdog from zombie-classifying this agent due to stale
   * lastActivity timestamps (the root cause of the Pi zombie state bug).
   *
   * NOTE: Pi tool names are lowercase ("bash", "write", "edit").
   * event.toolName is used (not event.name — that field does not exist on ToolCallEvent).
   * Path boundary uses event.input.path (not file_path — that is Claude Code's field name).
   */
  pi.on("tool_call", async (event) => {
    // Activity tracking: update lastActivity so watchdog knows agent is alive.
    // Fire-and-forget — do not await (avoids latency on every tool call).
    pi.exec("ov", [
      "log",
      "tool-start",
      "--agent",
      AGENT_NAME,
      "--tool-name",
      event.toolName,
    ]).catch(() => {});

    // 1. Block native team/task tools (all agents).
    if (TEAM_BLOCKED.has(event.toolName)) {
      return {
        block: true,
        reason: `Overstory agents must use 'ov sling' for delegation — ${event.toolName} is not allowed`,
      };
    }

    // 2. Block interactive tools (all agents).
    if (INTERACTIVE_BLOCKED.has(event.toolName)) {
      return {
        block: true,
        reason: `${event.toolName} requires human interaction — use ov mail (--type question) to escalate`,
      };
    }

    // 3. Block write tools for non-implementation capabilities.
    if (WRITE_BLOCKED.has(event.toolName)) {
      return {
        block: true,
        reason: `coordinator agents cannot modify files — ${event.toolName} is not allowed`,
      };
    }

    // 4. Path boundary enforcement for write/edit tools (all agents).
    // Pi uses event.input.path (not file_path — that is Claude Code's field name).
    if (WRITE_SCOPE_TOOLS.has(event.toolName)) {
      const filePath = String(
        (event.input as Record<string, unknown>)?.path ??
          (event.input as Record<string, unknown>)?.file_path ??
          (event.input as Record<string, unknown>)?.notebook_path ??
          "",
      );
      if (
        filePath &&
        !filePath.startsWith(WORKTREE_PATH + "/") &&
        filePath !== WORKTREE_PATH
      ) {
        return {
          block: true,
          reason:
            "Path boundary violation: file is outside your assigned worktree. All writes must target files within your worktree.",
        };
      }
    }

    // 5. Bash command guards.
    // Pi's bash tool is named "bash" (lowercase).
    if (event.toolName === "bash" || event.toolName === "Bash") {
      const cmd = String(
        (event.input as Record<string, unknown>)?.command ?? "",
      );

      // Universal danger guards (all agents).
      if (/\bgit\s+push\b/.test(cmd)) {
        return {
          block: true,
          reason:
            "git push is blocked — use ov merge to integrate changes, push manually when ready",
        };
      }
      if (/git\s+reset\s+--hard/.test(cmd)) {
        return {
          block: true,
          reason:
            "git reset --hard is not allowed — it destroys uncommitted work",
        };
      }
      const branchMatch = /git\s+checkout\s+-b\s+(\S+)/.exec(cmd);
      if (branchMatch) {
        const branch = branchMatch[1] ?? "";
        if (!branch.startsWith(`overstory/${AGENT_NAME}/`)) {
          return {
            block: true,
            reason: `Branch must follow overstory/${AGENT_NAME}/{task-id} convention`,
          };
        }
      }

      // Non-implementation agents: whitelist safe prefixes, block dangerous patterns.
      const trimmed = cmd.trimStart();
      if (SAFE_PREFIXES.some((p) => trimmed.startsWith(p))) {
        return; // Safe command — allow through.
      }
      if (DANGEROUS_PATTERNS.some((re) => re.test(cmd))) {
        return {
          block: true,
          reason:
            "coordinator agents cannot modify files — this command is not allowed",
        };
      }
    }

    // Default: allow.
  });

  /**
   * Tool execution end: fire-and-forget "ov log tool-end" for event tracking.
   * Paired with tool_call's tool-start fire for proper begin/end event logging.
   */
  pi.on("tool_execution_end", async (event) => {
    pi.exec("ov", [
      "log",
      "tool-end",
      "--agent",
      AGENT_NAME,
      "--tool-name",
      event.toolName,
    ]).catch(() => {});
  });

  /**
   * Agent end: log session-end when the agentic loop completes (task done).
   *
   * Awaited so it completes before Pi moves on. Without this handler, completed
   * Pi agents never transition to "completed" state in the SessionStore, causing
   * the watchdog to escalate them through stalled → nudge → triage → terminate.
   *
   * Fires when the agent finishes its work — before session_shutdown.
   */
  pi.on("agent_end", async (_event) => {
    await pi
      .exec("ov", ["log", "session-end", "--agent", AGENT_NAME])
      .catch(() => {});
  });

  /**
   * Session shutdown: safety-net session-end log for non-graceful exits.
   *
   * Awaited so it completes before Pi exits. Kept as a fallback in case
   * agent_end does not fire (e.g., crash, force-kill, Ctrl+C before task completes).
   *
   * Fires on Ctrl+C, Ctrl+D, or SIGTERM.
   */
  pi.on("session_shutdown", async (_event) => {
    await pi
      .exec("ov", ["log", "session-end", "--agent", AGENT_NAME])
      .catch(() => {});
  });
}
